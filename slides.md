
---

ALPHA BETA GAMMA

Notes:

Okay, at this point we've shown how Promises can fill a similar role to a traditional callback and we've touched on one of their key differentiators.

Another really key aspect of working with promises is the concept of chaining.

---

# Async Functions
# Async Iterators

Notes:
Promises are used under the hood by two other big language features: Async Functions and Async Iterators.

Async Functions were added in ES2017.
Async Iterators were added in ES2018.

---


---


# Other Topics

- Chaining
- Error handling
- Other language features built on promises
    - Async functions / await
    - Async iterators / for-await-of
    - (Proposal)
- Promise instance methods
    - then
    - catch
    - finally
- Promise methods
    - all
    - race
    - reject
    - resolve

---

# TODO

🔗⛓📝📑📆


- `[ ]` List of APIs that use promises
    - Fetch
    - Async iterators & for await of
- `[ ]` Promise concepts
    - `[ ]` resolve / reject
    - `[ ]` Chaining
- `[ ]` Trickier stuff
    - `[ ]` Promise.race()

---










<!--

1. Prep some work

    `var 💼 = () => console.log('👌')`

    &nbsp;

2. Pass it on

    `setTimeout(💼, 1000)`

3. 🤹

-->



























Now since my talk was a promise, you'll have to let me know if it succeeded.

# 🙄<!-- .element: class="fragment" -->